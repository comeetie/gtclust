---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# gtclust

<!-- badges: start -->
<!-- badges: end -->

gtclust builds on top of `?gtclust_graph` that enable hierarchical clustering and takes advantage of contiguity constraints induced by a graph. The contiguity naturally create a sparsely connected graph that can be leveraged to speed-up the calculations from $O(N^2D)$ to $O(M(log(M)+D))$ and deal with more than 10^5 data-points in seconds. To ease, the contiguity graph creation process, gtclust offers several interfaces to easily works with geographical, temporal (the gt in gtclust comes from here) or sequential data:

- `?gtclust_temp` to cluster sequential data, the contiguity graph follow from the data ordering 
- `?gtclust_poly` to cluster data associated to geographical polygons, the contiguity graph follow from shared boundaries
- `?gtclust_delaunay` to cluster data associated to geographical points, the contiguity graph is derived from the Delaunay triangulation of the points 
- `?gtclust_knn` to cluster data associated to geographical points, the contiguity graph is derived from the symmetrized knn graph of the geographical points  
- `?gtclust_dist` to cluster data associated to geographical points, the contiguity graph is derived from a threshold over distance the geographical points 

Several aggregations methods are available with all of the aforementioned interface. The classical linkage criterion available in `hclust` : 

- `ward`
- `centroid`
- `median`

Note that, ut `gtclust` also offers, two bayesian criterion that enable model selection :  

- `bayes_mom` mixture of multinomials for counts data
- `bayes_dgmm` diagonal mixture models for continuous features













## Installation

You can install the development version of gtclust from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("comeetie/gtclust")
```

## Example

This is a basic example, we first prepare some spatial polygons data, here the results at the municipality level in one french department for the  :

```{r example-data,message=FALSE}
library(gtclust)
library(dplyr)
library(sf)
data("modesshare.idf")

modesshare.idf <- modesshare.idf |> 
  rowwise(CODE_IRIS) |> 
  mutate(total = sum(c_across(nodep:tcom)))

modesshare.idf.percent = modesshare.idf |> 
  filter(total!=0) |>
  transmute(across(nodep:tcom,\(v){v/total})) 
  
```


Do the clustering and use the classical function from `?hclust` (`?plot.hclust` and `?cutree`):

```{r clustering,fig.show='hold',out.width="100%",fig.width=18,fig.height=8}
hc=gtclust_poly(modesshare.idf.percent,method="ward")
plot(hc,labels=FALSE)
cutree(hc,k=30) |> head(20)
```


You may also use the `?geocutree` function which build directly a spatial data.frame with the clustering results: 
```{r geoagg}
modesshare_agg = geocutree(hc,k=500)
```

```{r,echo=FALSE}
theme_map <- function(...) {
  theme_minimal() +
  theme(
    text = element_text( color = "#22211d"),
    axis.line = element_blank(),
    axis.text.x = element_blank(),
    axis.text.y = element_blank(),
    axis.ticks = element_blank(),
    axis.title.x = element_blank(),
    axis.title.y = element_blank(),
    panel.grid.major = element_line(color = "#ffffff", size = 0.2),
    panel.grid.minor = element_blank(),
    plot.background = element_rect(fill = "#ffffff", color = NA), 
    panel.background = element_rect(fill = "#ffffff", color = NA), 
    legend.background = element_rect(fill = "#ffffff", color = NA),
    panel.border = element_blank(),
    ...
  )
}
```

```{r plot,fig.show='hold',out.width="100%",fig.width=14,fig.height=5,echo=FALSE}
library(ggplot2)
library(ggpubr)
magg = ggplot(modesshare_agg)+
  geom_sf(aes(fill=voiture*100),size=0)+
  theme_map()+scale_fill_distiller("Car (%) :",palette = "Reds",direction = 1,limits=c(0,100))+
  ggtitle(paste0("Clustering with ",nrow(modesshare_agg)," clusters"))

mraw = ggplot(modesshare.idf.percent)+
  geom_sf(aes(fill=voiture*100),size=0)+
  theme_map()+
  scale_fill_distiller("Car (%) :",palette = "Reds",direction = 1,limits=c(0,100))+
  ggtitle(paste0("Raw data with ",nrow(modesshare.idf)," polygons"))

ggarrange(mraw,magg,nrow = 1,common.legend = TRUE,legend="bottom")
```



```{r plotparis,fig.show='hold',out.width="100%",fig.width=14,fig.height=5,echo=FALSE}
modesshare.paris = modesshare.idf.percent|>filter(substr(CODE_IRIS,1,2)==75)
env_paris=st_union(modesshare.paris) |> st_geometry()
modesshare_agg_paris = st_intersection(modesshare_agg,env_paris)

magg_paris = ggplot(modesshare_agg_paris)+
  geom_sf(aes(fill=tcom*100),size=0)+
  theme_map()+
  scale_fill_distiller("Transit (%) :",palette = "Greens",direction = 1,limits=c(0,100))+
  ggtitle(paste0("Clustering with ",nrow(modesshare_agg_paris)," polygons"))

mraw_paris = ggplot(modesshare.paris)+
  geom_sf(aes(fill=tcom*100),size=0)+
  theme_map()+
  scale_fill_distiller("Transit (%) :",palette = "Greens",direction = 1,limits=c(0,100))+
  ggtitle(paste0("Raw data with ",nrow(modesshare.paris)," polygons"))

ggarrange(mraw_paris,magg_paris,nrow = 1,common.legend = TRUE,legend="bottom")

```


```{r,fig.show='hold',out.width="100%",fig.width=10,fig.height=5,warning=FALSE}
res_mom = gtclust_delaunay(modesshare.idf |> st_centroid(),method="bayes_mom")
ggplot(data.frame(ts=res_mom$test.stat,K=(nrow(res_mom$data)-1):1))+
    geom_point(aes(x=K,y=ts))+theme_bw()+scale_y_continuous("Test statistic")+ggtitle("Bayesian test score","with respect to the number of cluster")
```

```{r benchplot,fig.show='hold',out.width="100%",fig.width=10,fig.height=5,echo=FALSE}
data("res.bench")

ggplot(res.bench|>mutate(time=time*10^-9))+
  geom_line(aes(x=N,y=time,group=alg,color=alg))+
  geom_point(aes(x=N,y=time,group=alg,color=alg))+
  geom_text(data=res.bench|>mutate(time=time*10^-9)|>filter(N==max(N)),aes(x=N,y=time,label=alg,color=alg),nudge_x = 500,hjust = "left",vjust="midlle")+theme_bw()+scale_x_continuous(expand = c(0.2,1.5))+scale_color_discrete(guide ="none")+scale_y_continuous("Time (s)")+ggtitle("Running times","of graph building and gtclust variants.")

```